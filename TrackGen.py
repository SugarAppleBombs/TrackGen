import sys
from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QApplication, QWidget, QFileDialog, QLabel, QDesktopWidget, QCheckBox, QComboBox
from PyQt5.QtGui import QIcon, QPixmap, QMovie
from PyQt5.QtCore import Qt
import os
from scipy import interpolate
import math as m
import numpy as np
import random
import gdal
import datetime as dt
import threading
import webbrowser

gdal.UseExceptions()

WINDOWS_LINE_ENDING = '\r\n'    #variables for switching from CR LF to LF and vice versa
UNIX_LINE_ENDING = '\n'

DICT_LENGTH = 23 #number of different language inclusions in the dictionary
SAMPLES = 3600  #number of longitudinal samples in AW3D30 DSM files
HGTDIR = 'hgt'  #name of the folder containing AW3D30 DSM files
DATA = 'data'   #name of the folder containing misc files

def core(q, name, path):#creating an empty GPX track file using a template
    output = open(path,"wb")
    tmplt = open(DATA + "/trk_tmplt.gpx","rb") #template of a GPX track file from Soviet Military Maps Android App(should be included with this script)
                                           #every filling function in this script is designed for a specific GPX template
    output.write(tmplt.read(330))
    output.write(name.encode(encoding='utf-8', errors='strict'))
    output.write(tmplt.read(20))
    output.write(name.encode(encoding='utf-8', errors='strict'))
    output.write(tmplt.read(18))
    for i in range(q):
        tmplt.seek(368)
        output.write(tmplt.read(60))
    output.write(tmplt.read(24))
    output.close()
    tmplt.close()


def coordpull(file, position):#importing coordinates of individual waypoints from GPX file generated by SAS.planet
    file.seek(0)
    d = file.read()
    d = d.replace(UNIX_LINE_ENDING, WINDOWS_LINE_ENDING)    #switching from LF to CR LF
    
    #getting the number of waypoints in the track
    file.seek(d.find("</rte>", position) - 53)  #finding the end of the track and going to the last point's numerator
    while True: #searching for a space character before the numerator
        if file.read(1) != " ":
            file.seek(file.tell() - 2)
        else:
            break
    f = ""
    while True: #reading the numerator
        ch = file.read(1)
        if ch == "<": break
        f = f + ch   
    wcount = 0  #settinf number of points to 0 in case read string isn't decimal or smth is wrong
    if f.isdecimal():
        wcount = int(f)
    file.seek(position - 4)
    
    coordinates = []
    coordinates.append(wcount)
    
    for i in range(wcount):
        file.read(16)
        tmp = ""
        while True:
            ch = file.read(1)
            if ch == '"': break
            tmp = tmp + ch
        coordinates.append(float(tmp))    #latitude
        while file.read(1)!="l": continue
        file.read(4)
        tmp = ""
        while True:
            ch = file.read(1)
            if ch == '"': break
            tmp = tmp + ch
        coordinates.append(float(tmp))    #longitute
        for x in range(4):
            file.readline()
            
    return coordinates

def coordin(coord, path):#filling in the coordinates into an empty GPX track file
    output = open(path,"r+b")
    temp = open(DATA + "/temp.gpx", "w+b")
    temp.write(output.read())
    output.seek(0)
    temp.seek(0)
    for i in range(6):
        output.readline()
        temp.readline()
    output.read(7)
    temp.read(7)
    f1 = 'lat="'
    f2 = '" lon="'
    f3 = '"'
    for i in range(coord[0]):
        tlat = round(coord[2*i+1], 8)
        tlat = str(tlat)
        tlat = tlat[0:11]
        tlon = round(coord[2*(i+1)], 8)
        tlon = str(tlon)
        tlon = tlon[0:11]
        output.write(f1.encode(encoding='utf-8', errors='strict'))
        output.write(tlat.encode(encoding='utf-8', errors='strict'))
        output.write(f2.encode(encoding='utf-8', errors='strict'))
        output.write(tlon.encode(encoding='utf-8', errors='strict'))
        output.write(f3.encode(encoding='utf-8', errors='strict'))
        output.write(temp.read(60))
    output.write(temp.read(55))
    temp.close()
    os.remove(DATA + "/temp.gpx")
    output.close()

def merc(input):#lat/lon coordinates to Mercator projection conversion
    l = input[0]
    output = []
    output.append(l)
    for i in range(l):
        lat = input[2*i+1]
        lon = input[2*(i+1)]
        x = m.radians(lon)  #conversion
        y = m.log((1+m.sin(m.radians(lat)))/(1-m.sin(m.radians(lat))))/2    #conversion
        output.append(x)
        output.append(y)
    return output

def frommerc(input):#Mercator projection to lat/lon coordinates conversion
    l = input[0]
    output = []
    output.append(l)
    for i in range(l):
        x = input[2*i+1]
        y = input[2*(i+1)]
        lon = m.degrees(x)  #conversion
        lat = m.degrees(2*m.atan(m.pow(m.e, y))) - 90   #conversion
        output.append(lat)
        output.append(lon)
    return output

def spline(length, array):#cubic spline for a track(should convert track to Mercator first)
    x_points = []
    y_points = []
    out = []
    out.append(length)
    
    deg = 1
    if array[0]==3:
        deg = 2
    if array[0]>3:
        deg = 3
    for i in range(array[0]):
        x_points.append(array[2*i+1])
        y_points.append(array[2*(i+1)])
    mytck,myu=interpolate.splprep([x_points,y_points], s = 0.0, k = deg)
    xnew,ynew= interpolate.splev(np.linspace(0,1,length),mytck)
    out[0] = len(xnew)
    for i in range(length):
        out.append(xnew[i] + xnew[i] * 0.0001/length * (random.random() - 0.5))     #resulting x/y coordinates are slightly randomized scaling with overall track length
        out.append(ynew[i] + ynew[i] * 0.0001/length * (random.random() - 0.5))
    return out

def haversine(lat1, lon1, lat2, lon2):#distance between two geographical points in kilometers(lat/lon coordinates)
    dlon = m.radians(lon2 - lon1)
    dlat = m.radians(lat2 - lat1)
    a = m.pow(m.sin(dlat/2), 2) + m.cos(m.radians(lat1))*m.cos(m.radians(lat2))*m.pow(m.sin(dlon/2), 2)     #haversine formula
    c = 2 * m.atan2(m.sqrt(a), m.sqrt(1-a))#haversine formula
    return 6371 * c

def dist(array):#roughly calculating track length in kilometers
    out = []
    out.append(array[0]-1)
    for i in range(array[0] - 1):
        d = haversine(array[2*i+1], array[2*(i+1)], array[2*i+3], array[2*(i+2)])
        out.append(d)
    return out

def ele(array):#reading elevations above sea level of each point in a track
    out = []
    temp_out = []
    out.append(array[0])
    temp_out.append(array[0])
    tiles = []
    t = 1
    tiles.append(t)
    tiles.append(m.floor(array[1]))
    tiles.append(m.floor(array[2]))
    flag = 1
    
    for i in range(array[0] - 1):
        tlat = m.floor(array[2*i+3])
        tlon = m.floor(array[2*(i+2)])
        for j in range(tiles[0]):
            if (tlat==tiles[2*j+1])and(tlon==tiles[2*(j+1)]):
                flag = 0
        if flag == 1:
            t = t + 1
            tiles[0] = t
            tiles.append(tlat)
            tiles.append(tlon)        
        else:
            flag = 1
    count = []  #array to keep the order of points in a track
    count.append(array[0])
    
    for i in range(tiles[0]):
        hgt_file = filename(tiles[2*i+1], tiles[2*(i+1)])
        if os.path.isfile(hgt_file):
            flag = True
            ds = gdal.Open(hgt_file)
            band = ds.GetRasterBand(1)
            elevation = band.ReadAsArray()  #reading elevation values in a tile
        else:
            flag = False
        
        for j in range(array[0]):
            lat = array[2*j+1]
            lon = array[2*(j+1)]
            
            lon_samples = SAMPLES   #number of latitudinal samples in AW3D30 DSM files is 3600 until 60 degrees N and S
            if abs(lat) > 60:
                lon_samples = 1800  #1800 from 60 to 80 degrees N and S
            if abs(lat) > 70:
                lon_samples = 1200  #1200 from 70 to 80 degrees N and S
            if abs(lat) > 80:
                lon_samples = 600   #600 from 80 degrees N and S
                
            if (m.floor(lat) ==  tiles[2*i+1])and(m.floor(lon) == tiles[2*(i+1)]):
                if flag:
                    lat_row = int(round((lat - int(lat)) * (SAMPLES - 1), 0))       #since data read from a tile is a 1-d array
                    lon_row = int(round((lon - int(lon)) * (lon_samples - 1), 0))   #converting x/y pointer to a single position
                    e = elevation[SAMPLES - 1 - lat_row, lon_row].astype(int)   
                    temp_out.append(e + round(random.random() + random.random() - random.random() - random.random(), 1))
                else:
                    temp_out.append(0.0)
                count.append(j+1)   #remembering position of track point we just read an elevation value for
        if flag:
            ds = None
            band = None
            elevation = None
    
    
    #sorting aquired elevation values according to order of points in a track
    count_sorted = []
    count_sorted.append(array[0])
    pointer = 1
    
    while len(count_sorted)<len(count):             #reading through count array and adding next elevation value only if
        for i in range(array[0]):                   #its position corresponds to a track point
            if count[i+1] == pointer:               #if count_sorted has the same number of values as count
                pointer = pointer + 1               #that means we sorted all of the values and placed them in out array
                count_sorted.append(count[i])
                out.append(temp_out[i+1])
                
    return out

def filename(lon, lat):#generating file name of a AW3D30 DSM file containing elevation value of a point with lon/lat coordinates
    if lat >= 0:
        ns = 'N'
    elif lat < 0:
        ns = 'S'

    if lon >= 0:
        ew = 'E'
    elif lon < 0:
        ew = 'W'

    hgt_file_path = HGTDIR + "/ALPSMLC30_"+str(ns)+str("{:03d}".format(m.floor(lon)))+str(ew)+str(m.floor(lat))+"_DSM.tif"
    
    return hgt_file_path
    
def elein(array, path):#filling in the elevation values into an resulting GPX track file
    output = open(path,"r+b")
    temp = open(DATA + "/temp.gpx", "w+b")
    temp.write(output.read())
    output.seek(0)
    temp.seek(0)
    for i in range(7):
        output.readline()
        temp.readline()
    for i in range(array[0]):
        output.write(temp.read(5))
        output.write(str(array[i+1]).encode(encoding='utf-8', errors='strict'))
        output.write(temp.read(7))
        for j in range(4):
            output.write(temp.readline())
    output.write(temp.read(52))
    temp.close()
    os.remove(DATA + "/temp.gpx")
    output.close()
    
def timein(array, path):#filling in the date/time values into an resulting GPX track file
    output = open(path,"r+b")
    temp = open(DATA + "/temp.gpx", "w+b")
    temp.write(output.read())
    output.seek(0)
    temp.seek(0)
    t = "T"
    z = "Z"
    for i in range(8):
        output.readline()
        temp.readline()
    for i in range(array[0]):
        output.write(temp.read(6))
        output.write(str(array[i+1].date()).encode(encoding='utf-8', errors='strict'))
        output.write(t.encode(encoding='utf-8', errors='strict'))
        output.write(str(array[i+1].time()).encode(encoding='utf-8', errors='strict'))
        output.write(z.encode(encoding='utf-8', errors='strict'))
        output.write(temp.read(8))
        for j in range(4):
            output.write(temp.readline())
    output.write(temp.read(41))
    temp.close()
    os.remove(DATA + "/temp.gpx")
    output.close()

def time(t1, dist, speed):#calculating the timestamp of each track point knowing timestamp of the first point and average speed
    time = []
    current_time = t1
    n = int(3600*dist/(2*speed))
    time.append(n)
    
    for i in range(n):
        time.append(current_time)
        current_time = current_time + dt.timedelta(seconds=2)
    
    return time

def speeds(times, dists):#calculating "instant" speed between two points using "real" distance beetween points and their time delta
    spd = []
    spd.append(dists[0])
    spd.append(0)
    
    for i in range(dists[0]):
        t = times[i+2]-times[i+1]
        t = t.total_seconds()/3600
        v = dists[i+1]/t
        spd.append(v)
    
    return spd

def speedin(array, path):#filling in the "instant" speed values into an resulting GPX track file
    output = open(path,"r+b")
    temp = open(DATA + "/temp.gpx", "w+b")
    temp.write(output.read())
    output.seek(0)
    temp.seek(0)
    for i in range(9):
        output.readline()
        temp.readline()
    for i in range(array[0]+1):
        output.write(temp.read(7))
        output.write(str(round(array[i+1], 1)).encode(encoding='utf-8', errors='strict'))
        output.write(temp.read(9))
        for j in range(4):
            output.write(temp.readline())
    output.write(temp.read(49))
    temp.close()
    os.remove(DATA + "/temp.gpx")
    output.close()

def pointin(name, cm, lat, lon, output_path, timestamp):
    tmplt = open(DATA + "/pnt_tmplt.gpx","rb")
    file = open(output_path, mode='wb')
    file.write(tmplt.read(334))
    file.write(str(lat).encode(encoding='utf-8', errors='strict'))
    file.write(tmplt.read(7))
    file.write(str(lon).encode(encoding='utf-8', errors='strict'))
    
    file.write(tmplt.read(9))
    
    file.write(name.encode(encoding='utf-8', errors='strict'))
    
    file.write(tmplt.read(14))
    
    file.write(cm.encode(encoding='utf-8', errors='strict'))
    
    file.write(tmplt.read(14))
    
    t = "T"
    z = "Z"
    file.write(str(timestamp.date()).encode(encoding='utf-8', errors='strict'))
    file.write(t.encode(encoding='utf-8', errors='strict'))
    file.write(str(timestamp.time()).encode(encoding='utf-8', errors='strict'))
    file.write(z.encode(encoding='utf-8', errors='strict'))
    
    file.write(tmplt.read(23))
    tmplt.close()
    file.close()

def generate(main_path, window):#main function
    main = open(main_path, encoding='cp1251', mode='r')
    #generating path and folder for output GPX file
    pth_holder = main_path.split('/')
    output_path = ""
    for i in range(len(pth_holder)-1):
        output_path = output_path + pth_holder[i]
        output_path = output_path + "/"
    smth = pth_holder[len(pth_holder) - 1].split('.')
    output_path = output_path + smth[0] + "_output"
    if not os.path.exists(output_path):
        os.makedirs(output_path)
    
    main_contents = main.read()
    main_contents = main_contents.replace(UNIX_LINE_ENDING, WINDOWS_LINE_ENDING)    #switching from LF to CR LF
    c_t = main_contents.count("<rte>")      #counting number of tracks in a file
    
    
    if window.point:
        c_p = main_contents.count("<wpt ")      #counting number of points in a file
        pointer = 0
        
        #waypoint attributes cause fuck OOP
        pnt_name = []
        pnt_cmt = []
        pnt_lat = []
        pnt_lon = []
        output_point_path = []
        pnt_done = []
        
        for i in range(c_p):
            s = main_contents.find("<wpt ", pointer)
            main.seek(s)
            main.read(10)
            tmp = ""
            while True:
                ch = main.read(1)
                if ch == '"': break
                tmp = tmp + ch
            pnt_lat.append(float(tmp))    #latitude
            while main.read(1)!="l": continue
            main.read(4)
            tmp = ""
            while True:
                ch = main.read(1)
                if ch == '"': break
                tmp = tmp + ch
            pnt_lon.append(float(tmp))   #longitute
            
            main.seek(main_contents.find("<name>", s) + 6)
            name = ""
            while True:
                ch = main.read(1)
                if ch == "<": break
                name = name + ch
            pnt_name.append(name.encode(encoding='cp1251', errors='ignore').decode(encoding='utf-8', errors='ignore'))
            
            output_point_path.append(output_path + "/" + pnt_name[i] + ".gpx")
            
            main.seek(main_contents.find("<cmt>", main.tell()) + 5)
            
            cmt = ""
            while True:
                ch = main.read(1)
                if ch == "<": break
                cmt = cmt + ch
            pnt_cmt.append(cmt.encode(encoding='cp1251', errors='ignore').decode(encoding='utf-8', errors='ignore'))
            
            pnt_done.append(False)
            
            pointer = main.tell()
        
        
        
    total_length = 0
    
    pointer = 0 
    pnt_counter = 0
    
    for i in range(c_t):
        s = main_contents.find("<rte>", pointer)
        main.seek(main_contents.find("<name>", s) + 6)
        trk_name = ""
        while True:
            ch = main.read(1)
            if ch == "<": break
            trk_name = trk_name + ch
        trk_name = trk_name.encode(encoding='cp1251', errors='ignore').decode(encoding='utf-8', errors='ignore')
        
        output_track_path = output_path + "/" + trk_name + ".gpx"
        
        main.seek(main_contents.find("<cmt>", main.tell()) + 5)
        
        trk_cmt = ""
        while True:
            ch = main.read(1)
            if ch == "<": break
            trk_cmt = trk_cmt + ch
                
        trk_cmt = trk_cmt.split(' ')
        tdate = trk_cmt[0].split('-')
        if len(tdate)!=3:
                tdate = trk_cmt[0].split('.')
        if len(tdate)!=3:
                tdate = trk_cmt[0].split('/')
        ttime = trk_cmt[1].split(':')
        year = tdate[2]
        month = tdate[1]
        day = tdate[0]
        hour = ttime[0]
        minute = ttime[1]
        second = ttime[2]
        
        months = {  #dictionary for months formats
            "Jan": 1,
            "Feb": 2,
            "Mar": 3,
            "Apr": 4,
            "May": 5,
            "Jun": 6,
            "Jul": 7,
            "Aug": 8,
            "Sep": 9,
            "Oct": 10,
            "Nov": 11,
            "Dec": 12,
            "January": 1,
            "February": 2,
            "March": 3,
            "April": 4,
            "May": 5,
            "June": 6,
            "July": 7,
            "August": 8,
            "September": 9,
            "October": 10,
            "November": 11,
            "December": 12,
            "Jan.": 1,
            "Feb.": 2,
            "Mar.": 3,
            "Apr.": 4,
            "May.": 5,
            "Jun.": 6,
            "Jul.": 7,
            "Aug.": 8,
            "Sep.": 9,
            "Oct.": 10,
            "Nov.": 11,
            "Dec.": 12
        }
        
        if year.isdecimal():
            year = int(year)
            if year < 100:
                year = year + 2000
        else:
            year = 0
            
        if month.isdecimal():
            month = int(month)
            if month > 12 or month <1:
                month = 1
        else:
            month = months.setdefault(month, 1)
            
        if day.isdecimal():
            day = int(day)
        else:
            day = 1
            
        if hour.isdecimal():
            hour = int(hour)
        else:
            hour = 0
            
        if minute.isdecimal():
            minute = int(minute)
        else:
            minute = 0
            
        if second.isdecimal():
            second = int(second)
        else:
            second = 0
        
        start = dt.datetime(year, month, day, hour, minute, second)
        speed = 30
        
        if len(trk_cmt) == 3:
            if trk_cmt[2].isdecimal():
                speed = int(trk_cmt[2])
        
        
        
        
        
        coords = coordpull(main, main_contents.find("<rtept", main.tell()))
        
        dst = dist(coords)
        
        times = time(start, sum(dst[1:]), speed)
        
        result_coords = frommerc(spline(times[0], merc(coords)))
        
        total_length += sum(dist(result_coords)[1:])
        
        elevations = ele(result_coords)
        
        spd = speeds(times, dist(result_coords))
        
        #next 5 functions create an empty GPX track file and fill it with data
        #they should be executed exactly in this order:
        #core()
        #coordin()
        #elein()
        #timein()
        #speedin()
        
        core(times[0], trk_name, output_track_path)
        
        coordin(result_coords, output_track_path)
        
        elein(elevations, output_track_path)
        
        timein(times, output_track_path)
        
        speedin(spd, output_track_path)
        
        print(trk_name)
        
        if (i+1)%10 == 1:
            tmp = window.lang_pack[10] + ", " + str(round(total_length, 3)) + " " + window.lang_pack[11]
        if 2 <= (i+1)%10 <= 4:
            tmp = str(i+1) + " " + window.lang_pack[12] + ", " + str(round(total_length, 3)) + " " + window.lang_pack[11]
        if 5 <= (i+1)%10 <= 9 or (i+1)%10 == 0:
            tmp = str(i+1) + " " + window.lang_pack[13] + ", " + str(round(total_length, 3)) + " " + window.lang_pack[11]
        window.label3.setText(tmp)
        window.update()
        
        pointer = main.tell()
    
        if window.point:
            for i in range(c_p):
                if not pnt_done[i]:
                    min_dist = haversine(pnt_lat[i], pnt_lon[i], result_coords[1], result_coords[2])
                    for j in range(1, times[0]):
                        point_dist = haversine(pnt_lat[i], pnt_lon[i], result_coords[2*j+1], result_coords[2*(j+1)])
                        min_dist = min([min_dist, point_dist])
                    if min_dist < 0.01:
                        print(pnt_name[i])
                        pnt_done[i] = True
                        pointin(pnt_name[i], pnt_cmt[i], pnt_lat[i], pnt_lon[i], output_point_path[i], times[j])
                        pnt_counter += 1
                        strng = str(pnt_counter) + " "
                        if pnt_counter%10 == 1:
                            strng += window.lang_pack[15] + " "
                            strng += window.lang_pack[18]
                        if 2 <= pnt_counter%10 <= 4:
                            strng += window.lang_pack[16] + " "
                            strng += window.lang_pack[19]
                        if 5 <= pnt_counter%10 <= 9 or pnt_counter%10 == 0:
                            strng += window.lang_pack[17] + " "
                            strng += window.lang_pack[19]
                        window.label4.setText(strng)
                        window.update()
    
    window.label2.setText(window.lang_pack[14])
    window.sign.setPixmap(window.checkmark)
    window.label1.setText("...")
    window.b2.setEnabled(False)
    
class App(QWidget):     #GUI stuff

    def __init__(self):
        super().__init__()
        self.title = 'TrackGen'
        self.left = 10
        self.top = 10
        self.width = 400
        self.height = 111
        self.initUI()
        self.up = True
        self.point = False
    
    def initUI(self):
        
        self.langs = []
        for file in os.listdir(DATA):
            if file.endswith(".lan"):
                temp = file[:len(file)-4]
                self.langs.append(temp)
                
        if os.path.isfile(DATA + "/config.cfg"): 
            self.cfg_file = open(DATA + '/config.cfg', 'r')
            self.cfg = self.cfg_file.read()
        else:
            self.cfg = "lan = eng"
            self.cfg_file = open(DATA + '/config.cfg', 'w')
            self.cfg_file.write(self.cfg)
        
        self.cfg_file.seek(self.cfg.find("lan") + 6)
        self.lang = ""
        while True:
            self.ch = self.cfg_file.read(1)
            if self.ch == '\n': break
            self.lang = self.lang + self.ch
        self.cfg_file.close()
        
        self.lang_pack = []
        self.lan = open(DATA + '/' + self.lang + '.lan', encoding='utf-8', mode='r')
        
        for i in range(DICT_LENGTH):
            self.tmp = self.lan.readline()
            self.lang_pack.append(self.tmp[:len(self.tmp)-1])
        self.lan.close()
        
        self.b1 = QtWidgets.QPushButton(self)   #file dialog button
        self.b1.resize(90, 22)
        self.b1.setText(self.lang_pack[0])
        self.b1.clicked.connect(self.openFileNameDialog)
        
        
        self.lan_box = QComboBox(self)      #language choice
        for i, language in enumerate(self.langs):
            self.lan_box.addItem(language)
            if self.lang == self.langs[i]:
                self.lan_box.setCurrentIndex(i)
        self.lan_box.move(339, 80)
        self.lan_box.activated[str].connect(self.onChanged)
        
        self.lan_txt = QLabel(self)
        self.lan_txt.setAlignment(Qt.AlignRight)
        self.lan_txt.resize(100, 20)
        self.lan_txt.setText(self.lang_pack[20])
        self.lan_txt.move(238, 84)
        
        #icons for info and fun
        self.play = QPixmap(DATA + '/play.png').scaled(20, 20, Qt.KeepAspectRatio, Qt.FastTransformation)
        #self.hourglass = QPixmap(DATA + '/hourglass.png').scaled(20, 20, Qt.KeepAspectRatio, Qt.FastTransformation)
        self.checkmark = QPixmap(DATA + '/checkmark.png').scaled(20, 20, Qt.KeepAspectRatio, Qt.FastTransformation)
        self.warning = QPixmap(DATA + '/warning.png').scaled(20, 20, Qt.KeepAspectRatio, Qt.FastTransformation)
        self.hourglass = QMovie(DATA + "/hourglass.gif")
        self.hourglass.start()
        
        self.b2 = QtWidgets.QPushButton(self)   #starting button that calls generate() function
        self.b2.resize(90, 22)
        self.b2.setText(self.lang_pack[1])
        self.b2.move(0, 77)
        self.b2.clicked.connect(self.gen)
        self.b2.setEnabled(False)
        
        self.label1 = QLabel(self)  #this label shows file path once it's chosen
        self.label1.resize(400, 20)
        self.label1.setText("...")
        self.label1.move(90, 0)
        
        self.endlabel = QLabel(self)    #label just for any text
        self.endlabel.resize(400, 20)
        self.endlabel.setText("TrackGen v1.0 - by Me, I wrote it all by myself (JK)||||sugarapplebombs@gmail.com")
        self.endlabel.move(0, 94)
        
        self.sign = QLabel(self)    #label for holding info and fun icons
        self.sign.resize(30, 30)
        self.sign.move(90, 73)
        self.sign.setPixmap(self.play)
        
        self.label2 = QLabel(self)  #status label
        self.label2.resize(400, 20)
        self.label2.setAlignment(Qt.AlignCenter)
        self.label2.setText(self.lang_pack[2])
        self.label2.move(0, 62)
        
        self.label3 = QLabel(self)  #this label shows how many tracks are found and processed
        self.label3.resize(400, 20)
        self.label3.setAlignment(Qt.AlignCenter)
        self.label3.setText(" ")
        self.label3.move(0, 48)
        
        self.label4 = QLabel(self)  #this label shows how many points are found and processed
        self.label4.resize(400, 20)
        self.label4.setAlignment(Qt.AlignCenter)
        self.label4.setText(" ")
        self.label4.move(0, 34)
        
        self.cb = QCheckBox(self.lang_pack[3], self)
        self.cb.move(1, 20)
        self.cb.resize(155, 20)
        self.cb.stateChanged.connect(self.changeState)
        
        self.help = QtWidgets.QPushButton(self)
        self.help.resize(70, 20)
        self.help.setText(self.lang_pack[22])
        self.help.move(220, 80)
        self.help.clicked.connect(self.open_help)
        
        self.gif = QLabel(self)
        self.gif.resize(63, 80)
        self.gif.setAlignment(Qt.AlignCenter)
        self.gif.move(337, 0)
        self.flag = False
        if os.path.isfile(DATA + "/giphy.gif"):
            self.flag = True
            self.movie_frame = QPixmap(DATA + "/giphy.gif")
            self.dim = QPixmap.size(self.movie_frame)
            self.movie = QMovie(DATA + "/giphy.gif")
            self.gif.setMovie(self.movie)
        self.easter_counter = 0
        self.easter_flag = False

        self.setWindowTitle(self.title)
        self.setGeometry(self.left, self.top, self.width, self.height)
        self.setFixedSize(self.width, self.height)
        qtRectangle = self.frameGeometry()
        centerPoint = QDesktopWidget().availableGeometry().center()
        qtRectangle.moveCenter(centerPoint)
        self.move(qtRectangle.topLeft())
        self.setWindowIcon(QIcon(DATA + '/knuckles.png'))
    
    def open_help(self):
        self.help_path = DATA + "/help.pdf"
        webbrowser.open_new(os.path.abspath(self.help_path))
        
    def onChanged(self, text):
        self.cfg = open(DATA + '/config.cfg', 'r+')
        self.tmp = self.cfg.read()
        self.tmp = self.tmp.replace(self.lang, text)
        self.lang = text
        self.cfg.seek(0)
        self.cfg.truncate()
        self.cfg.write(self.tmp)
        self.cfg.close()
        
        self.lan = open(DATA + '/' + self.lang + '.lan', encoding='utf-8', mode='r')
        for i in range(DICT_LENGTH):
            self.tmp = self.lan.readline()
            self.lang_pack[i] = self.tmp[:len(self.tmp)-1]
        self.lan.close()
        self.lan_txt.setText(self.lang_pack[20])
        self.b1.setText(self.lang_pack[0])
        self.b2.setText(self.lang_pack[1])
        self.cb.setText(self.lang_pack[3])
        self.label3.setText(" ")
        self.label4.setText(" ")
        self.lan_txt.setText(self.lang_pack[20])
        self.label2.setText(self.lang_pack[2])
        self.help.setText(self.lang_pack[22])
        self.sign.setPixmap(self.play)
    
    def openFileNameDialog(self):
        options = QFileDialog.Options()
        options |= QFileDialog.DontUseNativeDialog
        fileName, _ = QFileDialog.getOpenFileName(self,self.lang_pack[21], "","All Files (*);;GPX Files (*.gpx)", options=options)
        if fileName:
            self.label1.setText(fileName)
            self.label3.setText(" ")
            self.label2.setText(self.lang_pack[4])
            self.sign.setPixmap(self.play)
            self.b2.setEnabled(True)
    
    def changeState(self):
        self.point = not self.point
        if not self.easter_flag:
            self.easter_counter += 1
            if self.easter_counter == 42:
                if self.flag and self.dim.width()<=63 and self.dim.height()<=80:
                    self.movie.start()
                else:
                    self.gif.setText("There should\nhave been\na kitten\nbut someone\nstole it")
                self.easter_flag = True
                
    def gen(self):
        path = self.label1.text()
        form = path[len(path)-3] + path[len(path)-2] + path[len(path)-1]
        
        if os.path.isfile(path):
            if form == "gpx":
                file = open(path, 'rb')
                file.readline()
                file.readline()
                file.read(2)
                if file.read(10).decode("utf-8") == "<metadata>":
                    self.sign.setMovie(self.hourglass)
                    self.label2.setText(self.lang_pack[5] + "...")
                    self.label2.repaint()
                    path = self.label1.text()
                    self.label3.setText(self.lang_pack[6])
                    self.label4.setText(self.lang_pack[7])
                    gen = threading.Thread(target=generate, args=(path, self))
                    gen.start()    #main calculating is called
                else:
                    self.label2.setText(self.lang_pack[8])
                    self.sign.setPixmap(self.warning)
                    self.b2.setEnabled(False)
            else:
                self.label2.setText(self.lang_pack[8])
                self.sign.setPixmap(self.warning)
                self.b2.setEnabled(False)
        else:
            self.label2.setText(self.lang_pack[9])
            self.sign.setPixmap(self.warning)
            self.b2.setEnabled(False)
        
if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = App()
    ex.show()
    if ex.flag:
        ex.movie.stop()
    sys.exit(app.exec_())
    ex.hourglass.stop()
